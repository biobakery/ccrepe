\name{ccrepe}
\alias{ccrepe}
\title{
 Calculates compositionality-corrected p-values and q-values for compositional data using an arbitrary distance metric.
}
\description{
    ccrepe calculates compositionality-corrected p-values and q-values for compositional data by generating
	first a null distribution of the distance metric generated by permutation and renormalization of the data,
	and then by generating an alternative distribution of the distance metric by bootstrap resampling of the data.
        For greater detail, see ###TODO: CITATION###\cr
	The two distributions are compared using a pooled-variance Z-test to give a compositionality-corrected p-value.
        The p-values can be calculated for all appropriate (passing certain quality-control measures) pairwise comparisons,
        or for a subset of user-specified ones.\cr
        Q-values are additionally calculated using teh Benjamin-Hochberg-Yekutieli procedure ###TODO: CITATION###
 }
\usage{
 ccrepe(
 x = NA,
 y = NA,
 method = cor,
 method.args = list(),
 min.subj = 20,
 iterations = 1000,
 subset.cols.1 = c(0),				 
 subset.cols.2 = c(0), 
 errthresh = 1e-04,
 verbose = FALSE,
 iterations.gap = 100,
 distributions = NA)
 
}
\arguments{
  \item{x}{
   First dataframe or matrix containing the relative abundances in cavity1 : columns are bugs, rows are samples.
   (Rows should therefore sum to a constant.)\cr
   The subjectIDs, if present, are assumed to be the row names and NOT the first column of data.\cr 
}
  \item{y}{
   Second dataframe or matrix (optional) containing the relative abundances in cavity2: columns are bugs, rows are samples. \cr
   The subjectIDs, if present, are assumed to be the row names.
   If both x and y are specified, they will be merged by row names.  If no row names are specified for either or both datasets,
   the default is to use the row numbers as subject IDs.
}
 
  \item{method}{
   Similarity measure, such as cor or nc.score.  This similarity measure can be a pre-defined R function or user-defined.  If the latter,
   certain properties should be satisfied as detailed below (also see examples).  The default similarity measure is Spearman correlation.\cr
   A user-defined similarity measure should:\cr
   1.Be able to take either two inputs which are vectors or one input which is either a matrix or a dataframe\cr
   2.In the case of two inputs, return a single number\cr
   3.In the case of one input, return a matrix in which the (i,j)th entry is the similarity score for column i and column j in the original matrix\cr
   4.Resulting matrix (in the case of one input) must be symmetric\cr
   5.The inputs must be named x and y\cr
}
  \item{method.args}{
	A list of arguments for the measurement function.
	For example:  In the case of cor, the following would be acceptable:
	method.args = list(method=`spearman',use=`complete.obs'	).\cr	
        Note that this is the default behavior.
}
  \item{min.subj}{
  Minimum number of subjects that must be measured in a bug/feature/column in order to apply the similarity measure
  to that bug/feature/column.  This is to ensure that there are sufficient subjects to perform a bootstrap (default: 20).
}
  \item{iterations}{
  The number of iterations of bootstrap and permutation (default: 1000).
}
  \item{subset.cols.1}{
  Subset of columns from x to work on.  (Default: c(0) - meaning: Use all columns of x. 
  All the columns of x are used for normalization but calculations are performed only with the requested subset (by default, all columns). 
}
 \item{subset.cols.2}{
  Subset of columns from y to work on.  (Default: c(0) - meaning: Use all columns of y.  
  If applicable (y present), all the columns of y are used for normalization, but calculations are performed only with the requested subset (by default, all columns).  
}
  \item{errthresh}{
	Represents the probability of getting all 0's in a given bootstrapped column.
	If a bug/feature/column has a number of zeros that makes the probability of obtaining all zeros when sampling
        with replacement > errThresh, that bug/feature/column will be excluded from the subsequent analysis.  This is 
        to ensure that the standard deviation of the bootstrap sample is non-zero. (default= 0.0001)
}
  \item{verbose}{
	Indicator whether the user requested verbose output, which prints periodic progress of the algorithm through the dataset(s),
        as well as including more detailed output.  (default:FALSE)
}
 \item{iterations.gap}{
	If output is verbose - number of iterations after issue a status message (Default=100 - displayed only if verbose=TRUE).
}
  \item{distributions}{
	Output Distribution file  (default:NA).
}
}
 
\value{
	Returns a list containing the calculation results and the parameters used.\cr
	Default parameters shown:\cr
                min.subj,errThresh,sim.score,p.values,q.values
        Additional parameters if verbose=TRUE:
		iterations, subset.cols.1, subset.cols.2,\cr
		iterations.gap and sim.score.parameters\cr
        The descriptions of all parameters bug sim.score,p.values and q.values are above.\cr
        sim.score is a matrix of the simliarity scores for all the requested comparisons.  The (i,j)th
        element of sim.score correponds to the similarity score of column i (or the ith column of subset.cols.1) 
        and column j (or the jth column of subset.cols.1) in one dataset, or
        to the similarity score of ###DOUBLE CHECK THIS### of column i (or the ith column of subset.cols.1) in dataset x 
        and column j (or the jth column of subset.cols.2)in dataset y in the case of two datasets.\cr
        p.values is a matrix of the p-values for all the requested comparisons.  The (i,j)th element of p.values
        corresponds to the p-value of the (i,j)th element of sim.score.\cr
        q.values is a matrix of the Benjamini-Hochberg-Yekutieli FDR corrected p-values.  The (i,j)th element
        of q.values corresponds to the q-value fo the (i,j)th element of sim.score.
}
\author{
  Emma Schwager <emma.schwager@gmail.com> 
}
\examples{
%	data1<-matrix(rlnorm(21*23,1,1),nrow=21)
%	ccrepe.results <-ccrepe (x=data1,iterations=200) 
        > test.data
                        Bug 1     Bug 2     Bug 3     Bug 4
        Subject 1  0.29787234 0.2978723 0.2553191 0.1489362
        Subject 2  0.17073171 0.3170732 0.2682927 0.2439024
        Subject 3  0.09302326 0.3255814 0.2558140 0.3255814
        Subject 4  0.32352941 0.3235294 0.1470588 0.2058824
        Subject 5  0.17241379 0.1724138 0.4137931 0.2413793
        Subject 6  0.29729730 0.2162162 0.2702703 0.2162162
        Subject 7  0.22500000 0.3250000 0.2000000 0.2500000
        Subject 8  0.12820513 0.3589744 0.2307692 0.2820513
        Subject 9  0.20000000 0.2250000 0.2250000 0.3500000
        Subject 10 0.10256410 0.3076923 0.1794872 0.4102564
        > ccrepe(test.data,verbose=TRUE,min.subj=10)
        Completed  100  iterations
        Completed  200  iterations
        Completed  300  iterations
        Completed  400  iterations
        Completed  500  iterations
        Completed  600  iterations
        Completed  700  iterations
        Completed  800  iterations
        Completed  900  iterations
        Completed  1000  iterations
        $min.subj
        [1] 10

        $iterations
        [1] 1000

        $subset.cols.1
        [1] 0

        $subset.cols.2
        [1] 0

        $errthresh
        [1] 1e-04

        $verbose
        [1] TRUE

        $iterations.gap
        [1] 100

        $sim.score.parameters
                method            use
            "spearman" "complete.obs"

        $p.values
                  Bug 1     Bug 2     Bug 3     Bug 4
        Bug 1        NA 0.4368752 0.2781620 0.9411821
        Bug 2 0.4368752        NA 0.7786462 0.0398753
        Bug 3 0.2781620 0.7786462        NA 0.4753067
        Bug 4 0.9411821 0.0398753 0.4753067        NA

        $q.values
                 Bug 1    Bug 2    Bug 3    Bug 4
        Bug 1       NA 4.683029 4.969538 4.585856
        Bug 2 3.902524       NA 4.637000 2.137191
        Bug 3 3.727153 4.173300       NA 3.639278
        Bug 4 4.203701 1.068596 3.184369       NA

        $sim.score
                   Bug 1      Bug 2      Bug 3      Bug 4
        Bug 1  1.0000000 -0.3454545 -0.1636364 -0.7818182
        Bug 2 -0.3454545  1.0000000 -0.4424242  0.2727273
        Bug 3 -0.1636364 -0.4424242  1.0000000 -0.2727273
        Bug 4 -0.7818182  0.2727273 -0.2727273  1.0000000


        ccrepeSampleTestFunction  <- function(x, y = NA){
        #*************************************************************************************
        #*      ccrepeSampleTestFunction                                                     *
        #* This a simple example fot a test measurent function to be used with ccrepe        *
        #* used in the same fashion that cor would be used                                   *
        #*************************************************************************************
                 if(is.vector(x) && is.vector(y)) return(.5)                                   
                 if(is.matrix(x) && is.na(y)) return(matrix(rep(.5,ncol(x)^2),ncol=ncol(x)))   
                 if(is.data.frame(x) && is.na(y)) return(matrix(rep(.5,ncol(x)^2),ncol=ncol(x)))
                 else stop('ERROR')
        }
}